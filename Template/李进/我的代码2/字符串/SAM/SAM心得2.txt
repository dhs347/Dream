                                                      SAM心得2

    这一次，我们主要写SAM的多串模式，也就是关于广义后缀自动机的一些体会。

    先看看我们的程序中的一些主要接口与数组变量的定义：

    S空串状态start，总是为1；T最新的或者待扩展的结点状态编号；str_cnt多串串的个数；cnt当前总结点数目；M字符集大小

    pre[]就是link，表示后缀连接；go[][]表示转移连接；后缀自动机上的有向边只有这两种

    step[]就是max_len,表示每一个结点状态所对应的字符串子串集合中最大的字符串长度，简称最大长度

    rr[]是一个用户数组，用以维护一些和right集合相关的一些量，比如：每个串出现的最左最右下标（这样就可以打印串集合了）等，默认维护结点末尾字母

    dep[]表示结点在parent树中的深度(S深度为1),temp[]临时数组,toop[]拓扑序列，按照(dep,id)从小到大排序

    id[n]外围字符流中的第n个字符，所对应的在自动机中的结点编号（下文会说明，该结点未必有效）

    dp[],SS是用以在parent树上做树形dp或者启发式合并的数组和数据结构（常用set,map,seg_T,Treap,heap等）

    简单的接口概述：h()字符映射为自然数（0开始）,Init()用户初始化接口，I()单字符插入，多串模式不应该由用户调用

    Insert(s[],n,op)用户插入接口，插入字符串s[]前n个字符，op=1为反向插入

    Run(s[],n,op)在自动机上运行一个串s[]，参数同上，返回串锁定的结点状态编号（下文会说明）

    Go(p,c)，位于p节点，向c方向转移，如没有，则沿着后缀连接回退，直到为0

    get_dep()内部接口，记忆化搜索方式，获取结点在parent树上的深度；Toop()按照深度计数式拓扑排序，输出到toop[]

    Merge(x,y)用户自定义的树上合并函数，剥离于其他复杂的接口，表示y节点信息合并到x

    Count()重要用户接口，完成常规计数功能，采用树dp，计算每个结点状态p所代表的字符串集合中的每一个在每个插入串(编号k)中出现的次数cnt[p][k],1<=p<=cnt,1<=k<=str_cnt

    Q()用户主操作，凝练复杂过程，简化外部程序



    下面是几点心得：

1.从做法上看，广义后缀自动机和普通的自动机在增量法插入构建过程中，并无十分实质性的区别，一个体现在每个串插入前需要将T=S，表示待修改或者说待扩展的T状态变回初始S状态，

以这种野蛮却似乎有效的方法阻止字符插入串之间产生联系，但实际上这样并不能完全做到；第二个体现在树上dfs构建，以父节点为T进行增量

2.从本质上讲，我们看看广义在微观形态上与普通的区别：增加了不少的空状态节点，这里的空状态指的是节点所代表的字符串集合为空，也就是step[i]-step[pre[i]]=0

很显然，这种节点是无效的，也无益处，但是这样的构建方法十分简单，这就要求我们考虑清楚这种现象带来的影响是否是负面的

1）这种现象破坏了自动机中所有子串自动归类（由endpos等价关系确定的等价类）的精确表述，也就是说同一类的状态有可能分布在几个结点上，但是这几个结点必然相邻（树上的一个块）

2）我们看这几个结点中深度最小的节点，深度最小说明其他点都是他的子孙（儿子），表明pre指针总是指向他的，那么我们如果在每个字符串的每个前缀所对应的结点T（字符流中的每个字符）上插入时打标记

记录信息，那么如果我们做自下而上的树形dp（子树dp或子树合并），那么这一类节点的信息并就会回到这个深度最小的祖先，因此这个结点就变的有效了（此时只需要考虑那些无用的空状态节点是否会产生贡献的叠加，

如果没有就不会影响算法正确性）；如果我们做的是自上而下的树形dp，就没有这个特性，这个时候是否会产生不利的影响是需要深入仔细的思考的，具体问题具体分析

3）注意到上文讲的那个深度最小的祖先，其他空等价节点pre连向他，同时那些节点是没有go指针指向他们的(go入度为0，反证法)，因此如果在自动机上运行一个字符串是不会率先走入这些结点的，这是因为如果

一个c方向的转移成功了，必然就会走到一个新的“那个深度最小的祖先”（反证法，起点到一个等价字符串子串状态的路径是唯一的，这个可以数学归纳证明，从第一步转移开始每一步转移都唯一确定；那么如果一条路径通向

一个空状态结点，那么这个空状态结点就没有必要用pre指向那个祖先了），如果一个c方向的转移失败了，我们沿着pre也没有经过那些空状态（因为也没有pre指向他们，pre不会指向空的结点，用数学归纳，每个pre连接是都是根据的p的pre

如果p的pre是实的，那么那个实的点再转移一下也是实的，所以这个pre也是指向的实的）。这就是说，运行串不会走虚拟的空状态结点，这个是我们可以考虑的，考虑状态贡献叠加会不会重复出错。

3.本质的解决这些问题，可以修改广义自动机的构造过程，可能会嗦几行，但是更加精确，没有这些乱七八糟的考虑情况；那就是在刚进来的时候（不要新建结点），判断go[T][c]存在，然后分情况讨论；

一个是T变成go[T][c]，一个是go[T][c]拆成两半，T变成下一半。这样，我们可以写出广义多串模式的精确版本。其他不需要做任何更改；同时，step值可以直接用以代替dep作为拓扑排序的依据，这是因为

没有空状态，step[i]>step[pre[i]]，所以在step值相等的情况下，一个父亲不会跑到一个儿子的拓扑序后面（代码在第7点）

4.关于在自动机上运行一个串，锁定出来的结点状态对应的子串集合中的一个子串，可以精确的追踪下标l,r表示s[l..r]这个子串正好是结点状态空间的一个子串，这个子串的含义是该串s[]的r前缀与后缀自动机中所有子串的最长公共后缀

也就是说，锁定出来的子串是属于自动机的在s[1..r]中最长后缀，l到r这一段，也就是前缀对多串的匹配了。由这一层次的分析，我们可以做什么呢？那就是模式匹配。

我们可以求出任一个询问串，包含多串中的多少个，以及每个分别多少次；也就是说，求出第k个插入串在询问串中的出现次数cnt[k]，1<=k<=str_cnt，这个功能可以解决很多多串匹配的问题。

做法就是对每个插入串最后一个字符对应状态打标记，然后做自上向下的树dp或启发式合并，然后运行这个询问串，叠加贡献即可。（注意走到一个新状态，表明最右字符后移，要考虑能不能取得当前状态贡献，比较step与被锁定子串长度）

这个问题有个性质：就是说每个状态最多保存有一种本质不同的完整插入串（最长step）（从endpos等价角度证明）因此，如果要求询问串包含多少本质不同插入串，可以从这里思考。

上述的性质也可以等价的描述：每一个插入串的每一个前缀，对应着结点状态字符串集合中长度最大的那个字符串，且此集合内的其他字符串不是任何插入串的任何前缀。（集合中本质不同插入串前缀唯有一种）

5.在做树形dp时，注意单调性，树上的祖孙链单调性，实际上就是字符串区间包含单调性，其实也是关于后缀长度的单调性，很显然，出现次数也是单调的

如果题目对某个量有不等约束，那么在当前状态结点有贡献常常是parent树上连续的一条链，考虑沿着pre走到贡献链的边界在叠加，也是可行的。

6.运行锁定串状态的时候，go前进一次r++，pre回退一步，l+=step[i]-step[pre[i]]； Run()函数会自动求出答案ans，里面自带清零，用户只需要在Go中叠加贡献。

7.比较原始的精确广义后缀自动机版本的I()函数如下，模板中引入的是精确简化版：

    inline void I(int c) {
        ++n,c=h(c),p=T; if (!go[p][c]) T=new_node(step[T]+1,c);
        for (; p && !go[p][c]; p=pre[p]) go[p][c]=T;
        if (p==T) {
        	q=go[p][c];
        	if (step[p]+1==step[q]) T=q; else {
        		nq=new_node(step[p]+1,c);
        		rep(j,0,M-1) go[nq][j] = go[q][j];
        		for (; p && go[p][c] == q; p = pre[p]) go[p][c] = nq;
        		pre[nq]=pre[q],T=pre[q]=nq;
			}
		} else if (!p) pre[T] = S; else {
            q=go[p][c];
            if (step[p]+1==step[q]) pre[T]=q; else {
                nq=new_node(step[p]+1,c);
                rep(j,0,M-1) go[nq][j] = go[q][j];
                for (; p && go[p][c] == q; p = pre[p]) go[p][c] = nq;
                pre[nq]=pre[q],pre[T]=pre[q]=nq;
            }
        }
        id[n]=T; SS[T][str_cnt]++; //...
    }

可以看到的是，函数中多了一个大类的讨论，但实际上和下面及其的相似，所以我们考虑合并简化代码。

注意其他任何代码均不需要做任何变动。

事实上，简化版本的代码只比非广义单串标准版的代码多了两个短句：if (!go[p][c]) 和 int &X=(p==T?T:pre[T]);

8.4中所提到的问题是：求每个模式串在主串中的出现次数，这个问题是一个基础问题，被称之为模式串对主串求分布；

与之相对的还有一个问题：求主串在每个模式串中的出现次数，被称之为主串对模式串求分布，这两个基础版本我们均有封装

这个问题很容易，先套用合并模板，然后运行主串，得到一个状态，对应主串的一个最大可匹配后缀，比较长度是否等于step，如果不等，说明主串没有出现在任何模式串，否则输出结点状态的分布cnt[]

